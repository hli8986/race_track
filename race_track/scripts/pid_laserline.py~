#!/usr/bin/env python

import rospy, cv2, cv_bridge
import numpy as np
from sensor_msgs.msg import Image
from geometry_msgs.msg import Twist, Point, Pose
from nav_msgs.msg import Odometry
from tf import transformations
import tf
from sensor_msgs.msg import LaserScan
from math import atan2

def PID(setpoint, input_value):

    # Publish to cmd_vel topic
    twist_pub = rospy.Publisher('cmd_vel', Twist, queue_size=1)
    
    # Define current twist message
    current_twist = Twist()

    # Define new twist message
    new_twist = current_twist

    # Start counting time now
    current_time = rospy.Time.now()
    
    # Define last values
    last_time = rospy.Duration(1/1000)
    last_error = 0.0
    
    # Calculate time step
    dt = (current_time - last_time).to_sec()
    
    # Calculate error between setpoint and input value
    error = setpoint - input_value
    
    # Integral error
    i_error = 0.0
    i_error += error * dt
    
    # Derivative error
    d_error = 0.0
    d_error = error - last_error
    
    # PID gains
    kp = 0.0007
    ki = 0.000001
    kd = 0.0
    
    # Output value
    output = kp * error + ki * i_error + kd * d_error
    print output
    
    # define last error and last time
    last_error = error
    last_time = current_time
    
    # Update twist message with output
   # new_twist.angular.z = current_twist.angular.z + output
    #new_twist.linear.x = 1.0
    
    # Publish the new twist message
   # twist_pub.publish(new_twist)	      
      

class race_track:
  
  def __init__(self):
    #print(2.5)
    self.resume_delay = rospy.Duration.from_sec(10) 
    self.linear_speed_upper_limit = 1
    self.linear_speed_lower_limit = 0 
    self.angular_speed_upper_limit = 0.75#0.75
    self.bridge = cv_bridge.CvBridge()
    rospy.sleep(5)
    self.last_press = rospy.Time.now() - self.resume_delay  
    self.pub = rospy.Publisher('cmd_vel',Twist,queue_size=1)  
    self.twist = Twist()

    self.sub = rospy.Subscriber("front/scan", LaserScan,self.laser_callback)
    self.image_sub = rospy.Subscriber('front/image_raw',Image, self.callback)
    #self.bridge = cv_bridge.CvBridge()
    

    #cv2.namedWindow("window", 1)
    

    #self.sub_odm = rospy.Subscriber("/odometry/filtered", Odometry, self.odom_callback)

    #self.image_sub = rospy.Subscriber('front/image_raw', Image, self.image_callback)
    #self.laser_sc = rospy.Subscriber('/front/scan', LaserScan, self.laser_callback)
    #self.cmd_vel_pub = rospy.Publisher('/cmd_vel', Twist, queue_size=1)
    #self.twist = Twist()
    #self.posit=[]

  def laser_callback(self,msg):
    global forward_range
    forward_range = msg.ranges[0:360]#[320:380]

  def callback(self,data):
    image = self.bridge.imgmsg_to_cv2(data,desired_encoding='bgr8')
    hsv = cv2.cvtColor(image, cv2.COLOR_BGR2HSV)
    lower_yellow = np.array([ 0, 0,  79])
    upper_yellow = np.array([40, 40, 191])
    mask = cv2.inRange(hsv, lower_yellow, upper_yellow)
    #print(3)

    h, w, d = image.shape
    search_top =h/4
    search_bot = search_top + 15
    mask[0:search_top, 0:w] = 0
    mask[search_bot:h, 0:w] = 0
    M = cv2.moments(mask)
    #forward_range = self.ranges[300:400]

    flag_wall = 0
    flag_wall_dir = 0
    current_vel = 0.3
    for i in forward_range:
	    if i < 2.5:       
		   flag_wall = 1
	    
            if i > 3:
		   flag_wall = 0 
		       
    if flag_wall == 0:

	    if M['m00'] > 0:
	      cx = int(M['m10']/M['m00'])
	      cy = int(M['m01']/M['m00'])
	      
	      cv2.circle(image, (cx, cy), 10, (0,255,0), -1)
	      self.twist.linear.x = np.clip( self.twist.linear.x + 0.005 , self.linear_speed_lower_limit, self.linear_speed_upper_limit)
             
              self.twist.angular.z = PID(   self.twist.angular.z ,0.75)# np.clip((0.0008 * -(cx - w/2)) ,-self.angular_speed_upper_limit, self.angular_speed_upper_limit)
            else:
	      self.twist.linear.x = np.clip(self.twist.linear.x - 0.04, self.linear_speed_lower_limit, self.linear_speed_upper_limit)
              self.twist.angular.z = PID( self.twist.angular.z,0.75)#np.clip(self.twist.angular.z + 0.03,-self.angular_speed_upper_limit, self.angular_speed_upper_limit)
    else:       
	      self.twist.linear.x = np.clip(self.twist.linear.x - 0.2, self.linear_speed_lower_limit, self.linear_speed_upper_limit)
	      if self.twist.linear.x == 0:
		      for i in forward_range:
			     if  i<2.5:
				self.twist.angular.z = PID( 0.1 ,1.75)#np.clip(self.twist.angular.z + 0.1,-self.angular_speed_upper_limit, 1.75)
				#if i < 1.5:       
				   #  for i in range(100000):
				self.twist.linear.x = PID( 0.2 ,1)#np.clip(self.twist.linear.x + 0.2, self.linear_speed_lower_limit, self.linear_speed_upper_limit)

			      
		              #self.twist.linear.x = np.clip(self.twist.linear.x + 0.2, self.linear_speed_lower_limit, self.linear_speed_upper_limit)

    if rospy.Time.now() - self.last_press > self.resume_delay:
        self.pub.publish(self.twist)
    else:
        self.twist.linear.x = self.linear_speed_lower_limit
        self.twist.angular.z = 0
                                  
        
    cv2.imshow("window", image)
    cv2.waitKey(3)

  

rospy.init_node('follower')
follower = race_track()
rospy.spin()
