#!/usr/bin/env python

import rospy
import numpy as np
import cv2
import math
import matplotlib.pyplot as plt
from cv_bridge import CvBridge, CvBridgeError
from sensor_msgs.msg import Image
from geometry_msgs.msg import Twist

class img_feature:

  def __init__(self):

    # Initialize cv_bridge
    self.bridge = CvBridge()
    
    # Subscribe to image_raw topic
    self.sub = rospy.Subscriber("/front/image_raw", Image, self.callback, queue_size = 1)
    
  def callback(self, data):

    # Convert ROS image to cv2 bgr image
    cv_image = self.bridge.imgmsg_to_cv2(data, "bgr8")
    
    # Convert bgr color to hsv
    hsv = cv2.cvtColor(cv_image, cv2.COLOR_BGR2HSV)
    
    # Get height and width of the current view 
    h_view, w_view, d_view = cv_image.shape
    
    # Define range of red in HSV
    red_lower = np.array([0, 70, 50])
    red_upper = np.array([10, 255, 255])
    
    # Create a mask for red color and remove small bubbles with eroding and dilating
    mask = cv2.inRange(hsv, red_lower, red_upper)
    mask = cv2.erode(mask, None, iterations=2)
    mask = cv2.dilate(mask, None, iterations=2)
    
    # Find boundaries for the red objects
    contours, hierarchy = cv2.findContours(mask, 1, cv2.CHAIN_APPROX_NONE)
    cv2.drawContours(mask, contours, -1, (255, 0, 0), 3)
    
    # Defien center coordinates of the contour
    cx = 0
    cy = 0
    
    # Find the biggest contour
    if len(contours) > 0:
      c = max(contours, key=cv2.contourArea)
      
      # Get moments from the contour
      M = cv2.moments(c)
      
      # Retrieve the centroid value
      cx = int(M["m10"] / M["m00"])
      cy = int(M["m01"] / M["m00"])
      
      # Draw a circle for the center of the detected object
      cv2.circle(cv_image, (cx, cy), 5, (255, 255, 0), 3)
      
      linear_x = PID_linear(h_view, cy)
      PID_angular(w_view, cx, 0, linear_x, 0, 0)
      print "target acquired"
      
    elif len(contours) == 0:
#      PID_angular(0, 0, 0, 0, 1, -math.pi/2)
      PID_angular(0, 0, 1, 0.5, 0, 0)
      print "looking for target"
    
    # Draw a circle for the center of the window
    cv2.circle(cv_image, (w_view/2, h_view/2), 5, (0, 128, 0), 3)
    
    # Show the original image
    cv2.imshow("Original", cv_image)
    
#    # Show the masked image
#    cv2.imshow("Masked", mask)
    
#    # Processed image
#    processed = cv2.bitwise_and(cv_image, cv_image, mask=mask)
    
#    # Show the post-processed image
#    cv2.imshow("Processed", processed)
    
    # Delay for 5 milliseconds
    cv2.waitKey(5)
   
    
def PID_angular(setpoint, input_value, l_constant, linear_x, a_constant, angular_z):

    # Publish to cmd_vel topic
    twist_pub = rospy.Publisher('cmd_vel', Twist, queue_size=1)
    
    # Define current twist message
    current_twist = Twist()

    # Define new twist message
    new_twist = current_twist

    # Start counting time now
    current_time = rospy.Time.now()
    
    # Define last values
    last_time = rospy.Duration(1/1000)
    last_error = 0.0
    
    # Calculate time step
    dt = (current_time - last_time).to_sec()
    
    # Calculate error between setpoint and input value
    error = setpoint - input_value
    
    # Integral error
    i_error = 0.0
    i_error += error * dt
    
    # Derivative error
    d_error = 0.0
    d_error = error - last_error
    
    # PID gains
    kp = 0.00065
    ki = 0.0001
    kd = 0.0
    
    # Output value
    output = kp * error + ki * i_error + kd * d_error
#    print output
    
#    plt.plot(output)
#    plt.show()
    
    # define last error and last time
    last_error = error
    last_time = current_time
    
    # Update twist message with output
    if a_constant == 0:
     new_twist.angular.z = current_twist.angular.z + output
    elif a_constant == 1:
     new_twist.angular.z = angular_z
    
    if l_constant == 0:
      new_twist.linear.x = current_twist.linear.x + linear_x
    elif l_constant == 1:
      new_twist.linear.x = linear_x
    
    # Publish the new twist message
    twist_pub.publish(new_twist)
    
def PID_linear(setpoint, input_value):
    
    # Define current twist message
    current_twist = Twist()

    # Define new twist message
    new_twist = current_twist

    # Start counting time now
    current_time = rospy.Time.now()
    
    # Define last values
    last_time = rospy.Duration(1/1000)
    last_error = 0.0
    
    # Calculate time step
    dt = (current_time - last_time).to_sec()
    
    # Calculate error between setpoint and input value
    error = setpoint - input_value
    
    # Integral error
    i_error = 0.0
    i_error += error * dt
    
    # Derivative error
    d_error = 0.0
    d_error = error - last_error
    
    # PID gains
    kp = 0.001
    ki = 0.0000001
    kd = 0.0
    
    # Output value
    output = kp * error + ki * i_error + kd * d_error
#    print output
    
#    plt.plot(output)
#    plt.show()
    
    # define last error and last time
    last_error = error
    last_time = current_time
    
    return output

    
if __name__ == '__main__': 
  
  # Initialize node for the tracking
  rospy.init_node('line_follow', anonymous = True)
  
  # Call image function
  ic = img_feature()
  
  try:
#    PID()
    rospy.spin()  
  except KeyboardInterrupt:
    print("Shutting down")
    
  # Close all windows
  cv2.destroyAllWindows()
